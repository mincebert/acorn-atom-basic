; ATOM BASIC source code



; BBCSWROM defined if compiling for the BBC Micro as a SWROM

.if BBC == 0


; assembling for Acorn Atom (original ROM)

*=$c000

WORKSP=$0200
VARSTORE=$38c

; OS calls
OSCLI=$fff7
OSWRCH=$fff4
OSCRLF=$ffed
OSECHO=$ffe6
OSRDCH=$ffe3
OSLOAD=$ffe0
OSSAVE=$ffdd
OSRDAR=$ffda
OSSTAR=$ffd7
OSBGET=$ffd4
OSBPUT=$ffd1
OSFIND=$ffce
OSSHUT=$ffcb

; vectors
WRCVEC=$208
BPTVEC=$216


.else


; assembling for the BBC as a sideway ROM


*=$8000

; we need two pages of workspace, starting here
WORKSP=$7200

; start of fixed variable area
VARSTORE=$738c


; --- PAGED ROM HEADER ---


swrom:		JMP lang		; language entry
		JMP svc			; service entry (none)
		.byte $c2		; = 6502 code
		.byte <copyright	; copyright offset
		.byte 1			; version byte
		.text "Atom BASIC"	; title
		.byte 0			; terminator
		.text "0.1"		; version string
copyright:	.byte 0			; terminator
		.text "(C) Acorn"	; copyright
		.byte 0			; terminator
		.dword 0		; 2nd processor relocation address


lang:		; enable interrupts
		cli
		; reset start pointer
		LDX #$ff
		TXS
		; don't bother resetting break vector as Atom BASIC will do
		; that jump to normal Atom BASIC cold start
		JMP start

svc:		; do nothing for now
		; should have a *ATOMBASIC command or something similar
		RTS



; --- ATOM COS THUNKING CODE ---


BBCOSCLI=$fff7
BBCOSWRCH=$ffee
BBCOSNEWL=$ffe7
BBCOSRDCH=$ffe0
BBCOSASCI=$ffe3


; Atom COS call is very similar, except that the command is stored at the fixed
; address $0100, rather than the address in Y,X, and clears the decimal flag.

OSCLI:		LDX #$00
		LDY #$01
		JSR BBCOSCLI
		CLD
		RTS


; Aside from the address changes, these works identically.

OSWRCH=BBCOSWRCH	; TODO: check this isn't really OSASCI
OSRDCH=BBCOSRDCH


; This is largely identical, except the Atom COS guarantees N+Z are 0.
; Can't think of a simple way to ensure this, at the moment, so ignore it.

OSCRLF:		JMP BBCOSNEWL


; The BBC MOS doesn't have an equivalent call, but this is basically an OSRDCH
; which prints out the entered character.

OSECHO:		JSR BBCOSRDCH
		JMP BBCOSASCI


; TODO: convert these but we're not using them except when we implement
; filing calls

OSLOAD=$ffe0
OSSAVE=$ffdd
OSRDAR=$ffda
OSSTAR=$ffd7
OSBGET=$ffd4
OSBPUT=$ffd1
OSFIND=$ffce
OSSHUT=$ffcb


; --- VECTORS ---


BBCWRCVEC=$20e
WRCVEC=BBCWRCVEC

BBCBPUTV=$218
BPTVEC=BBCBPUTV


.endif


; --- START OF CODE ---


; Interpreter Command Lookup Table
;
; Each sub table is terminated by a negative byte.
; A termination byte of $FF causes BRK to be executed on failure.
; Any other value >=$80 is the MSB of the jump address (LSB is in the table
; at c0ee).

cmd_tbl:
cmd_tbl_op:	; operators
		.text "<"
		.text "="
		.text ">"
		.text $fe

		; function interpreter
cmd_tbl_fnint:	.text "-"
		.text "+"
cmd_fnp:	.text >do_fnp

		; numerical assignments
cmd_tbl_numass:	.text "#"
		.text "("
		.text "!"
		.text "?"
		.text "R"
		.text "T"
		.text "L"
		.text "C"
		.text "A"
		.text "P"
		.text "E"
		.text "G"
		.text "B"
		.text "F"
		; error?
cmd_unk:	.text $f0

cmd_tbl_for:	; [FOR ...]
		.text "T"
cmd_end:	.text $ff
		;
cmd_to:		.text "O", >do_to		; [T]O

cmd_tbl_forto:	; [FOR ... TO ...]
		.text "S"
		.text $cb
		;
cmd_step	.text "TEP", >do_step		; [S]TEP

cmd_tbl_if:	; [IF ...]
		.text "T", >do_then
		;
cmd_then:	.text "HEN", >do_then

cmd_tbl_str:	; check for valid string
		.text """"
		.text "$"
cmd_str:	.text >do_str			; [$]
		;
cmd_quote	.text >do_quote			; ["]

cmd_strvar:	.text >do_strvar
cmd_tbl_input:	; INPUT...
		.text "$"
		; numerical variable input
cmd_2c:		.text ","
		.text >do_input_num

cmd_2e:		.text "$&;", $0d, ",", $c3, $c5, $c2
cmd_ne:		.text ">", >do_ne		; [<]>
cmd_le:		.text "=", >do_le		; [<]=
cmd_lt:		.text >do_lt			; [<]
cmd_eq:		.text >do_eq			; [=]
cmd_ge:		.text "=", >do_ge		; [>]=
cmd_gt:		.text >do_gt			; [>]
cmd_fnn:	.text >do_fnn			; [fn -]
cmd_40:		.text "R", $c7, $c7
cmd_43:		.text "OA", $fe
cmd_46:		.text "$", $c7
cmd_ch:		.text "H", >do_ch		; [C]H
cmd_len:	.text "EN", $c9			; num [L]EN
cmd_4d:		.text "ND", $c7
cmd_hash:	.text >do_hash			; [#]
cmd_bktop:	.text >do_bktop			; [(]
cmd_pling:	.text >do_pling			; [!]
cmd_query:	.text >do_query			; [?]
cmd_rnd:	.text "ND", >do_rnd		; [R]ND
cmd_top:	.text "OP", >do_top		; [T]OP
cmd_count:	.text "OUNT", >do_count		; [C]OUNT
cmd_abs:	.text "BS", >do_abs		; [A]BS
cmd_ptr:	.text "TR", >do_ptr		; [P]TR
cmd_ext:	.text "XT", >do_ext		; [E]XT
cmd_get:	.text "ET", >do_get		; [G]ET
cmd_bget:	.text "GET", >do_bget		; [B]GET
cmd_fin:	.text "IN", >do_fin		; [F]IN
cmd_fout:	.text "OUT", >do_fout		; [F]OUT
		.text $c3, $c3
cmd_78:		.text "RINT", $c3
cmd_7d:		.text "NL"
cmd_7f:		.text "UNIGRF!?$PDLSB*E", $f0
		.text "AVE", $cf
		.text "EW", >do_new
		.text "O", $cc
		.text "ET", $c3
		.text "INK", $c3
		.text "IST", $ca
		.text "OAD", >ceed
		.text "NTIL", $cc
		.text "EXT", $ca
		.text "F", $c5
		.text "NPUT"
cmd_input_do:	.text >do_input
here:		.text "OSUB", $cb
		.text "OTO", $cc
		.text "ETURN", $cb
		.text "EM", $c5
		.text "UN", $f1
		.text "OR", $cb
		.text "ND", $cd
		.text "GET", $cf
		.text "PUT", $cf
		.text "HUT", $cf
		.text "PUT", $cf
		.text "TR", $cf
		.text "UT", $cf, $c3, $c4, $cd, $c4
		.text ",", $fe


; Jump Address and Return Branch Table
;
; The offset from the start of the c000 table where a character is matched is
; used to index into this table and retrieve a new index into the c000 table
; for the following characters.

off_tbl:
		; operators
		.text cmd_ne - cmd_tbl			; <
		.text cmd_eq - cmd_tbl			; =
		.text cmd_ge - cmd_tbl			; >
		.text $c0

		; function interpreter
		.text cmd_fnn - cmd_tbl			; fn -
		.text cmd_fnp - cmd_tbl			; fn +
		.text <do_fnp

		; numerical assignments
		.text cmd_hash - cmd_tbl		; #
		.text cmd_bktop - cmd_tbl		; (
		.text cmd_pling - cmd_tbl		; !
		.text cmd_query - cmd_tbl		; ?
		.text cmd_rnd - cmd_tbl			; R
		.text cmd_top - cmd_tbl			; T
		.text cmd_len - cmd_tbl			; L
		.text cmd_count - cmd_tbl		; C
		.text cmd_abs - cmd_tbl			; A
		.text cmd_ptr - cmd_tbl			; P
		.text cmd_ext - cmd_tbl			; E
		.text cmd_get - cmd_tbl			; G
		.text cmd_bget - cmd_tbl		; B
		.text cmd_fin - cmd_tbl			; F
		.text $2e

		; [FOR ...]
		.text cmd_to - cmd_tbl			; T
		.text $ac
		;
		.text cmd_end - cmd_tbl			; [T]O
		.text <do_to

		; [FOR ... TO ...]
		.text cmd_step - cmd_tbl		; S
		.text $be
		;
		.text cmd_end - cmd_tbl			; [S]TEP
		.text cmd_end - cmd_tbl
		.text cmd_end - cmd_tbl
		.text <do_step

		; [IF ...]
		.text cmd_then - cmd_tbl		; T
		.text <do_then
		;
		.text cmd_end - cmd_tbl			; [T]HEN
		.text cmd_end - cmd_tbl
		.text cmd_end - cmd_tbl
		.text <do_then

		; check for valid string
		.text cmd_quote - cmd_tbl		; "
		.text cmd_str - cmd_tbl			; $
		.text <do_str				; [$]
		;
		.text <do_quote				; ["]

		.text <do_strvar			; [$]
		; [INPUT ...]
		.text cmd_strvar - cmd_tbl		; $
		; numerical variable input
		.text cmd_input_do - cmd_tbl		; ,
		.text <do_input_num

off_2e:		.text $76, $77, $34, $34, $7c, $3f, $4a, $78	; $&;<CR>,
		.text cmd_le - cmd_tbl, <do_ne		; [<]>
		.text cmd_lt - cmd_tbl, <do_le		; [<]=
		.text <do_lt				; [<]
		.text <do_eq				; [=]
		.text cmd_gt - cmd_tbl, <do_ge		; [>]=
		.text <do_gt				; [>]
		.text <do_fnn				; [fn -]
off_40:		.text $45, $22, $31, $40		; =
off_44:		.text $4d, $4d, $42, $53		; =
		.text cmd_unk - cmd_tbl			; [C]H
		.text <do_ch
off_4a:		.text $15, $15, $bd			; [L]EN
off_4d:		.text $45, $45, $14			; $
		.text <do_hash				; [#]
		.text <do_bktop				; [(]
		.text <do_pling				; [!]
		.text <do_query				; [?]
		.text cmd_unk - cmd_tbl			; [R]ND
		.text cmd_unk - cmd_tbl
		.text <do_rnd
		.text cmd_unk - cmd_tbl			; [T]OP
		.text cmd_unk - cmd_tbl
		.text <do_top
		.text cmd_ch - cmd_tbl			; [C]OUNT
		.text cmd_unk - cmd_tbl
		.text cmd_unk - cmd_tbl
		.text cmd_unk - cmd_tbl
		.text <do_count
		.text cmd_unk - cmd_tbl			; [A]BS
		.text cmd_unk - cmd_tbl
		.text <do_abs
		.text cmd_unk - cmd_tbl			; [P]TR
		.text cmd_unk - cmd_tbl
		.text <do_ptr
		.text cmd_unk - cmd_tbl			; [E]XT
		.text cmd_unk - cmd_tbl
		.text <do_ext
		.text cmd_unk - cmd_tbl			; [G]ET
		.text cmd_unk - cmd_tbl
		.text <do_get
		.text cmd_unk - cmd_tbl			; [B]GET
		.text cmd_unk - cmd_tbl
		.text cmd_unk - cmd_tbl
		.text <do_bget
		.text cmd_fout - cmd_tbl		; [F]IN
		.text cmd_unk - cmd_tbl
		.text <do_fin
		.text cmd_unk - cmd_tbl			; [F]OUT
		.text cmd_unk - cmd_tbl
		.text cmd_unk - cmd_tbl
		.text <do_fout
		.text $90				; IN
off_77:		.text $35, $e3, $8f, $8f		; OUT
off_7b:		.text $8f, $34				; RINT
		; TODO out of sync somewhere above here!
off_7d:		.text $94, $a0, $a8			; NL...
off_80:		.text $ad, $b1				; ???
off_82:		.text $bd, $c1, $cd, $e9, $ea, $eb, $78, $97		; ...UNIGRF!?...
off_8a:		.text $99, $d3, $df, $ec, $d0, $4b, $8f, $8f, $8f	; ...$PDLSB*E
off_93:		.text $0a, $8f				; ???
off_95:		.text <do_new, <do_new, $8f		; [N]EW
off_98:		.text $f0, $9c				; EW
off_9a:		.text $8f, $25				; O
off_9c:		.text $8f, $8f, $8f			; ET
off_9f:		.text $b2, $a4, $9c, $8f		; INK
off_a3:		.text $51, $99, $8f, $8f		; IST
off_a7:		.text $ed, $8f, $8f, $8f		; OAD
off_ab:		.text $8f, $d2, $8f, $8f, $8f		; NTIL
off_b0:		.text $cd, $b3, $66, $8f		; EXT
off_b4:		.text $8f, $8f				; F
off_b6:		.text $8f
		.text <do_input
off_b8:		.text $8f, $8f		; INPUT
		.text $8f
off_bb:		.text $8f, $d2, $8f, $b8, $8f		; OSUB
off_c0:		.text $05, $ca, $c7, $8f		; OTO
off_c4:		.text $8f, $8f, $ec, $8f, $8f, $75	; ETURN
off_ca:		.text $8f, $8f, $41			; EM
off_cd:		.text $8f, $8f, $57			; UN
off_d0:		.text $8f, $8f, $98			; OR
off_d3:		.text $d7, $8f, $8f			; ND
off_d6:		.text $e3, $db, $8f, $8f		; GET
off_da:		.text $c5, $90, $8f, $8f		; PUT
off_de:		.text $b6, $8f, $8f			; TR
off_e1:		.text $8f, $8f, $e6, $8f, $47, $8f, $8f	; UT
off_e8:		.text $95, $ee				; ,
off_ea:		.text $06, $5c, $0f, $35		; ???


; Interpreter Single Byte Command Lookup Table

c1dd:		.text "-+|:", $FE
		.text "*/%!?&", $FE
		.text ")", $FF
		.text "=", $FF
		.text "!?$", $FF
		.text "=!?", $FF
		.text "'", $22, $FE


; LSB Execution Address Table for Single Byte Commands

c1f8:		.text $B7, $9A, $D3, $EF, $EF, $13, $5E, $70
		.text $B3, $9C, $7B, $7B, $78, $78, $78, $78, $EE, $06, $5C, $5C, $E5, $75, $7B, $7B
		.text $6F, $7A


; MSB Execution Address Table for Single Byte Commands

c212:		.text $C7, $C7, $C7, $C7, $C7, $C8, $C8, $C8, $C8, $C8, $C8, $C8, $C2, $C2
		.text $C2, $C2, $C3, $C4, $CD, $CD, $C3, $CD, $CD, $CD, $C3, $C3


; Function Interpreter subroutine
;
; Evaluates an arbitrarily complex function pointed to by (5),Y where Y=?3
; and stores the result on the Workspace Stack pointed to by ?4.

c22c:		JSR cf3e		; get <factor> into Y register§
		STY $0f			; hex print flag, updated by comma


; Search for ',' subroutine

c231:		LDX #$ed		; set table pointer to C0ED to search
					; for ',' only


; Interpreter subroutine
;
; Interprets the command word at C0EE,X against text at ($5),?3.

c233:		LDY $3			; get the interpreter pointer

					; SKIP ANY PRECEDING SPACES

c235:		DEY
c236:		INY			; Point to the next character in text
		LDA ($5),Y		; ... and fetch it
		CMP #" "		; Is it <SPC>?
		BEQ c236		; ... yes, skip to next character

			; GET FIRST CHARACTER MATCH

c23d:		STY $5e			; Save current interpreter index
		STA $52			; Save character under interpretation
c241:		INX			; Point to next character in command table
		LDA cmd_tbl - 1,X	; ... and fetch it
		BMI c26b		; ... a negative byte indicates the end of
					; the initial letter table
		CMP $52			; Same as character under interpretation?
		BNE c241		; ... no, try next initial letter

			; MATCH THE REST OF THE COMMAND WORD

c24b:		LDA off_tbl - 1,X	; Get index to rest-of-command-word table
		TAX			; This is now the new table pointer
c24f:		INX			; Point to the next character in the table
		INY			; Point to the next character under analysis
		LDA cmd_tbl - 1,X	; Fetch the next command table character
		BMI c26b		; ... a negative byte means a successful
					; match of end of command table
		CMP ($5),Y		; Same as character under interpretation?
		BEQ c24f		; ... yes, now try to match the next character
		LDA ($5),Y		; ... no, get the failed character under
					; interpretation
		CMP #"."		; Is it '.' indicating an abbreviation?
		BEQ c264		; ... yes, so it's a successful match
		LDY $5e			; ... no, so reset the interpreter pointer
		BPL c24b		; ... and try to match the next word in the
					; command table

			; SUCCESSFUL ABREVIATED MATCH - SKIP TO
			; THE END OF THE COMMAND WORD IN THE TABLE

c264:		INX			; Point to the next character in the table
		LDA cmd_tbl - 1,X	; and fetch it
		BPL c264		; Keep incrementing to reach the command
					; word's negative termination byte
		INY			; Point to the next character under analysis

			; Test for success or failure

c26b:		CMP #$fe		; reached the end of the command table ?
		BCS c2aa		; ... yes, return or execute BRK as required

			; GET THE COMMAND WORD'S JUMP ADDRESS INTO
			; ZERO PAGE AND JUMP TO IT

c26f:		STA $53			; Termination byte is the MSB jump address
		LDA off_tbl - 1,X	; Get the LSB jump address from the table
		BCC c29f		; Dump it to $52, update $3 and $4 and
					; jump to the command address now in ($52)

c276:		LDX $4
		RTS


; Search for '=' subroutine
;
; Looks for '=', skipping leading spaces, in text pointed to by (5),Y
; where Y=?3.
; Executes BRK if the first non space character is not '='.
; Returns with Y register pointing to the next character.
; Returns with the interpreter pointer ?3 updated.
; Returns with X register loaded with the w/s pointer ?4.

c279:		LDX #$e			; Point to '=' at c1eb


; Single Byte Command Interpreter
;
; Interpretes the single byte symbols at C1DD.
; Enter with X register pointing to the symbol table to be used.

c27b:		LDY $3			; Get the interpreter pointer
c27d:		DEY
c27e:		INY
c27f:		LDA ($5),Y		; Get the next character from text
c281:		CMP #$20		; Is it <spc> ?
c283:		BEQ c27e		; ... yes, skip preceding spaces
c285:		CMP c1dd,X		; Is it this single byte symbol ?
c288:		BEQ c296		; ... yes, go fetch its jump address
c28a:		STA $52			; ... no, save the character under analysis
c28c:		INX			; Point to the next table symbol
c28d:		LDA c1dd,X		; ... and fetch it
c290:		BMI c2a8		; ... a negative byte means the end of table
					; termination byte has been reached
c292:		CMP $52			; Does this symbol match the text ?
c294:		BNE c28c		; ... no, try the next symbol

		; MATCHED SYMBOL - FETCH JUMP ADDRESS

c296:		LDA c212,X		; Get the MSB jump address
c299:		STA $53			; ... into workspace
c29b:		LDA c1f8,X		; Get the LSB jump address
c29e:		INY			; Increment the text pointer past the
					; character just successfully interpreted
c29f:		STA $52			; Dump the MSB jump address to workspace
c2a1:		STY $3			; Update the interpreter pointer
c2a3:		LDX $4			; Get the current workspace pointer
c2a5:		JMP ($52)		; ... and jump

		; END OF TABLE ACTION

c2a8:		CMP #$fe		; Non-destructive failure ?
c2aa:		BEQ c276		; ... yes, load workspace pointer and return
c2ac:		BRK			; ... no, error 174


; Execute the command 'NEW'
;
; Resets the print field length LSB variable '@' to the default of 8.
; Exits back to direct mode.

do_new:		JSR c4e4		; Perform the interpreter post test
		BNE c2b6


; 'Cold Start' routine - Text at $2900
;
; Comes from BREAK routine at $FF94.
; Points the text pointer ?$12 at $2900 and performs a 'NEW'.

start:
c2b2:		LDA #$29
c2b4:		STA $12			; Set text pointer to page $29


; 'Cold Start' routine - unspecified text Space
;
; If coming from the BREAK routine at $FF97, the text space is $8200.
; Performs an 'NEW' at the current text space.

c2b6:		LDA #$d
c2b8:		LDY $12			; Get the text page
c2ba:		STY $e			; Set MSB TOP to the start of text
c2bc:		LDY #$0
c2be:		STY $d			; Set LSB TOP to the start of text
c2c0:		STA ($d),Y		; First byte of text is $D
c2c2:		LDA #$ff		; Get a text terminator
c2c4:		INY			; Point to the second byte of text
c2c5:		STA ($d),Y		; ..and dump the terminator
c2c7:		INY			; Point to the third byte of text
c2c8:		STY $d			; ..and set LSB TOP
c2ca:		LDA #$8			; Get the default print length
c2cc:		STA WORKSP + $121	; ..and set LSB integer variable '@'


; Direct Command Handler
;
; Entered after a command execution or at the end of a program.

c2cf:		LDA #$3e		; Get '>'
c2d1:		CLD
c2d2:		JSR cd0f		; Print the contents of the accumulator and
					; get a line of text terminated by <CR> from
					; the keyboard into the $100 buffer

		; INITIALISE THE (5),Y TEXT POINTER TO THE
		; START OF THE $100 BUFFER

c2d5:		LDX #$1
c2d7:		STX $6
c2d9:		DEX
c2da:		STX $5

		; CLEAR LINE NUMBER TO ZERO - DIRECT MODE

c2dc:		STX $1			; Clear the MSB line number
c2de:		STX $2			; Clear the LSB line number

		; SET BRKVEC TO THE DEFAULT ROUTINE AT C9D8

c2e0:		LDA #<c9d8
c2e2:		STA $202
c2e5:		LDA #>c9d8
c2e7:		STA $203

		; SET THE BASIC ERROR HANDLER TO THE
		; DEFAULT TEXT AT C9E7

c2ea:		LDA #<c9e7
c2ec:		STA $10
c2ee:		LDA #>c9e7
c2f0:		STA $11

		; EXECUTE THE TEXT POINTED BTO BY (5),Y

c2f2:		LDX #$ff
c2f4:		TXS			; Reset the stack poimter
c2f5:		LDA #$0
c2f7:		STA $4			; Reset the workspace stack pointer
c2f9:		STA $3			; Reset the interpreter index
c2fb:		STA $15			; Reset the FOR....NEXT stack pointer
c2fd:		STA $13			; Reset the GOSUB...RETURN stack pointer
c2ff:		STA $14			; Reset the DO...UNTIL stack pointer
c301:		LDX #$34

		; CLEAR THE LABEL (@ to z) ADDRESS STACK

c303:		STA VARSTORE,X
c306:		DEX
c307:		BNE c303

c309:		JSR c434		; If the first non space character is
					; alphabetic and the the subsequent
					; is not (but is not '.')
c30c:		BCS c32f		; ... then interpret a simple integer variable
					; definition

					; CHECK FOR TEXT LINE ENTRY OR DELETION

c30e:		JSR c46a		; interpret a decimal string as a number
				; into the w/s stack, and increment ?4
c311:		BCC c316		; ... invalid number
c313:		JMP cdc9		; Deal with line insertion and removal

				; EXECUTE A DIRECT COMMAND AT $100

c316:		LDX #cmd_7d - cmd_tbl	; Set the interpreter table pointer to $C???
c318:		JMP c233		; ... and interpret & execute the command


; Execute the command 'THEN'

do_then:	JSR c434		; If the first non space character is
					; alphabetic and the the subsequent
					; is not (but is not '.')
c31e:		BCS c32f		; ... then treat this as an integer variable
					; assignment
c320:		LDX #cmd_7f - cmd_tbl	; Set the interpreter table pointer to $C???
c322:		JMP c233		; ... and interpret & execute the command


; Execute the command 'LET'

c325:		JSR c434		; If the first non space character is
					; alphabetic and the the subsequent
					; is not (but is not '.')
c328:		BCS c32f		; ... then interpret a simple integer variable
c32a:		LDX #$10		; Otherwise set the table pointer
c32c:		JMP c27b		; ... and interpret a ?, ! or $ definition

		; EXECUTE {simple integer variable} =, ? OR

		; ! ASSIGNMENT

c32f:		LDX #$14		; Set table pointer to
c331:		JMP c27b		; Search for & execute '=', '?' or '!'


; Execute the command 'PRINT'

c334:		SEC
c335:		ROR $f			; Set bit 7 of the hex print flag to get
					; the default decimal print mode
c337:		JSR c372
c33a:		LDX #cmd_2e - cmd_tbl	; Set the interpreter table pointer to $C???
c33c:		JMP c233		; ... and interpret & execute '=', '?' or '!'


; Execute and Print an Arbitrarily Complex Expression

c33f:		JSR c78b		; Evaluate an arbitrarily complex
					; expression, followed by a single byte
					; symbol, followed by '<', '=' or '>'
c342:		JSR c3cb		; Copy the last level of the w/s stack to
					; $52(LSB)..$55(MSB) & increment w/s pointer
c345:		LDA $f			; Print in decimal ?
c347:		BMI c36a		; ... yes, branch to decimal print routine


; Print the 4 byte Word at $52..$55 in Hexadecimal subroutine
;
; Prints the word $52(LSB) to $55(MSB) as a 4 byte hex word in field
; size @ suppressing any leading zeros.
; Destroys A,X,Y registers.

c349:		LDX #$0
c34b:		STX $27			; Clear the negative flag used by the
					; print routine at C5C8
c34d:		LDY #$0			; Clear index to the 4-byte word
c34f:		LDA $52,Y		; Get the current byte of the word
c352:		PHA			; Save a copy for upper nibble conversion
c353:		AND #$f			; Mask off the upper nibble
c355:		STA $45,X		; ... and dump the lower nibble to w/s
c357:		PLA			; Restore the copy
c358:		LSR A			; )
c359:		LSR A			; )
c35a:		LSR A			; )
c35b:		LSR A			; ) bring the upper nibble down to the lower nibble
c35c:		INX			; Increment the w/s pointer
c35d:		STA $45,X		; ... and dump the converted upper nibble
c35f:		INX			; Increment the w/s pointe for the next byte
c360:		INY			; Point to the next byte of theword
c361:		CPY #$4			; Done all $ bytes ?
c363:		BCC c34f		; ... no, go for the next one
c365:		JSR c5c8		; Print the digit stream suppressing leading
					; zeros
c368:		BMI c337		; Branch ALWAYS to interpret the next item
					; in the print stream


; Decimal print routine

c36a:		JSR c589		; Print the lowest level of the w/s stack as
					; a signed decimal number in field size @
c36d:		BMI c337		; Branch ALWAYS to interpret the next item
					; in the print stream


c36f:		JSR cd54		; Send <CR><LF> to OSWRCH
c372:		LDX #$18		; Set the interpreter table pointer to $C???
c374:		JMP c27b		; ... and interpret 'O' ??


; ??? Print routine ???

c377:		JSR ca4c		; Increment COUNT and send the contents of
					; the accumulator to OSWRCH
c37a:		LDA ($5),Y
c37c:		INY
c37d:		CMP #$d
c37f:		BEQ c39c + 1
c381:		STY $3
c383:		CMP #$22
c385:		BNE c377
c387:		LDA ($5),Y
c389:		CMP #$22
c38b:		BNE c372
c38d:		INY
c38e:		BCS c377
c390:		JSR c78b
c393:		JSR c3cb
c396:		ORA $54
c398:		ORA $53
c39a:		BEQ c3aa
c39c:		LDY #$0
c39e:		LDA ($52),Y
c3a0:		CMP #$d
c3a2:		BEQ c337
c3a4:		JSR ca4c
c3a7:		INY
c3a8:		BNE c39e
c3aa:		LDA $52
c3ac:		JSR ca4c
c3af:		JMP c337


; Execute the command 'LINK'

c3b2:		JSR c3c8		; Evaluate an arbitrarily complex function
					; to $52(LSB)..$55(MSB)
c3b5:		JSR c4e4		; Do interpreter post-test
c3b8:		LDA WORKSP + $122	; Load accumulator with LSB integer 'A'
c3bb:		LDX WORKSP + $139	; Load X register with LSB integer 'X'
c3be:		LDY WORKSP + $13a	; Load Y register with LSB integer 'Y'
c3c1:		JSR c2a5		; Indirect jump to ($52)
c3c4:		CLD			; Ensure binary mode after nasty user's prog
c3c5:		JMP c55b		; Return to execute the next command whether
					; by program execution or in direct mode


; Function Interpreter subroutine
;
; Evaluates an arbitrarily complex function pointed to by (5),Y where y=?3
; and stores the result on the Workspace Stack pointed to by ?4 and also
; on the arithmetic workspace stack at $52(LSB)..$55(MSB).
; The (5),Y pointer is consolidated before return, so that (5),0 points to
; the last character in the string interpreted.
; The workspace stack pointer ?4 is NOT incremented.

c3c8:		JSR c8bc		; Evaluate an arbitrarily complex numeric
					; expression pointed to by (5),Y


; Copy Current Level of the Workspace Stack to $52..$55 subroutine
;
; Enter with the X register pointing to the current level of the workspace
; stack, so that level (X-1) is copied to $52(LSB)..$55(MSB).
; The workspace stack pointer ?4 is updated and decremented.

c3cb:		LDY #$52


; Copy Current Level of the Workspace Stack to zero page subroutine
;
; Enter with the X register pointing to the current level of the workspace
; stack, so that level (X-1) is copied to $52(LSB)..$55(MSB).
; Enter with the Y register pointing to the LSB of the four consecutive
; bytes that are the zero page destination.
; The workspace stack pointer ?4 is updated and decremented.

c3cd:		DEX
c3ce:		STX $4


; Copy Current Level of the Workspace Stack to zero page subroutine
;
; Enter with the X register pointing to the level of the workspace stack
; required to be copied to $52(LSB)..$55(MSB).
; Enter with the Y register pointing to the LSB of the four consecutive
; bytes that are the zero page destination.
; The workspace stack pointer ?4 is NOT TOUCHED !

c3d0:		LDA $16,X
c3d2:		STA $0,Y
c3d5:		LDA $25,X
c3d7:		STA $1,Y
c3da:		LDA $34,X
c3dc:		STA $2,Y
c3df:		LDA $43,X
c3e1:		STA $3,Y
c3e4:		RTS


; Deals with Numerical Assignments
;
; Sets pre-interpreted variable to an arbitrarily complex expression.
; Enter with the variable number (0=@, 1=A, etc TO 26=Z) in the LSB of
; the workspace stack at level (?4-1).

c3e5:		JSR c4e1		; Evaluate a numerical expression onto the
					; w/s stack and do post-test.
c3e8:		JSR ca2f		; Assign value on the w/s stack to a variable
					; number on the w/s stack
c3eb:		JMP c55b		; Return to execute the next command whether
					; by program execution or in direct mode


; Execute the command '!'
;
; Sets pre-interpreted vector to an arbitrarily complex expression.

c3ee:		JSR c8bc		; Evaluate an arbitrarily complex numeric
					; expression pointed to by (5),Y
					; which is the ! base address
c3f1:		JSR ce93		; Interpret an '=' sign and a numerical
					; expression following, and copy the LSB
					; to the base address on stack
c3f4:		LDA $26,X		; Get the second LSB from stack
c3f6:		INY			; Point to the second address
c3f7:		STA ($52),Y		; ... and dump the second LSB
c3f9:		INY			; Point to the third address
c3fa:		LDA $35,X		; Get the third LSB from stack
c3fc:		STA ($52),Y		; ... and dump the third LSB
c3fe:		INY			; Point to the fourth address
c3ff:		LDA $44,X		; Get the fourth LSB from stack
c401:		STA ($52),Y		; ... and dump the fourth LSB
c403:		JMP c55b		; Return to execute the next command whether
					; by program execution or in direct mode


; Execute the command '?'
;
; Sets pre-interpreted byte to an arbitrarily complex expression.

c406:		JSR c8bc		; Evaluate an arbitrarily complex numeric
					; expression pointed to by (5),Y
c409:		JSR ce93		; Interpret an '=' sign and a numerical
					; expression following, and copy the LSB
					; to the base address on stack
c40c:		JMP c55b		; Return to execute the next command whether
					; by program execution or in direct mode


; Execute OS commands
;
; Deals with * prefixed commands.
; Copies the string after the '*' prefix pointed to by (5),Y where Y=?3
; to the Direct Mode buffer at $100 and then calls OSCLI indirected
; by vector ($206,$207).

c40f:		LDX #$0			; Initialise the Direct Mode buffer pointer
c411:		LDA ($5),Y		; Get character under analysis from text
c413:		STA $100,X		; ... and copy to the direct mode buffer
c416:		STY $3			; Update the interpreter pointer
c418:		INY			; Point to the next character of text
c419:		INX			; Point to the next slot in the buffer
c41a:		CMP #$d			; Was the last character <CR> ?
c41c:		BNE c411		; ... no, keep copying
					; (defaults to $F8EF)
c41e:		JSR OSCLI		; ... yes, finished, so call OSCLI
c421:		JMP do_input_num		; Perform post test, check for <ESC> etc and
					; return to execute the next command whether
					; by program execution or in direct mode


; Floating Point ROM Check subroutine
;
; Returns with Carry set if the FP ROM at $D000 exists.

c424:		LDA $d000
c427:		CMP #$aa
c429:		BNE c463
c42b:		LSR A
c42c:		CMP $d001
c42f:		BNE c463
c431:		LDY $5e
c433:		RTS


; Interpreter Alphabetic Pre-Test subroutine
;
; Reads the first non-space character pointed to by (5),Y where y=?3
; and tests it and the following character.
; 1st character: If it is alphabetic (@ to Z), the character number
;		(where @=0, A=1 to Z=26) is stored in the LSB of the
;		current level of the workspace stack, pointed to by ?4,
;		and the second character is tested.
;		However if it is not alphabetic, the routine is exited
;		with Carry clear and the interpreter pointer Y=?3
;		pointing to the second character.
; 2nd character: If it is not alphabetic and also not '.', the workspace
;		pointer X=?4 is incremented before return with Carry set
;		and the interpreter pointer Y=?3 pointing to this
;		second character.
;		Otherwise return with pointers as above but with Carry clear.

c434:		LDY $3			; Get the interpreter pointer
c436:		BPL c43b		; ... branch always

c438:		INY
c439:		STY $3
c43b:		LDA ($5),Y		; Get the character under interpretation
c43d:		CMP #$20		; If it's a space...
c43f:		BEQ c438		; ... then skip to the next character
c441:		CMP #$5b		; Test for valid alphabetic character
c443:		BCS c463		; ... invalid
c445:		SBC #$3f		; Convert to @=0, A=1,...to Z=26
c447:		BCC c464		; ... invalid alphabetic character
c449:		LDX $4			; Get the workspace pointer
c44b:		STA $16,X		; Dump the first character on the LSB of
					; the current workspace slot
c44d:		INY			; Point to the next character
c44e:		LDA ($5),Y		; ... and fetch it
c450:		CMP #$2e		; Is it '.' ?
c452:		BEQ c463		; ... yes, clear Carry and quit
c454:		CMP #$5b		; Is it >='[' ?
c456:		BCS c45c		; ... yes, set Carry and quit
c458:		CMP #$40		; Is it <='@' ?
c45a:		BCS c463		; ... yes, clear Carry and quit

c45c:		INX			; Increment workspace stack pointer
c45d:		STX $4			; Update workspace stack pointer
c45f:		SEC
c460:		STY $3			; Interpreter points to second character
c462:		RTS

c463:		CLC
c464:		RTS


; Read Decimal String subroutine
;
; Reads string pointed to by (5),Y where Y=?3 as ASCII decimal characters,
; stores the binary result in the Workspace Stack at 16,X where X=?4
; and increments the Workspace Stack pointer ?4.
; If the first non-space character is not a number, BRK is executed.
; Destroys A,X,Y registers.

c465:		JSR c434		; If next symbol is a <variable>, BRK
c468:		BCS c424 + 1

		; GET POSITIVE NUMBER
		; (return with Carry clear if no number)

c46a:		LDX #$0
c46c:		LDY $3
c46e:		STX $52
c470:		STX $53
c472:		STX $54
c474:		STX $55
c476:		DEY
c477:		INY
c478:		LDA ($5),Y
c47a:		SEC
c47b:		SBC #$30
c47d:		BMI c4d3
c47f:		CMP #$a
c481:		BCS c4d3
c483:		LDX $53
c485:		PHA
c486:		LDA $55
c488:		PHA
c489:		LDA $54
c48b:		PHA
c48c:		LDA $52
c48e:		ASL A
c48f:		ROL $53
c491:		ROL $54
c493:		ROL $55
c495:		BMI c46a + 1
c497:		ASL A
c498:		ROL $53
c49a:		ROL $54
c49c:		ROL $55
c49e:		BMI c46a + 1
c4a0:		ADC $52
c4a2:		STA $52
c4a4:		TXA
c4a5:		ADC $53
c4a7:		STA $53
c4a9:		PLA
c4aa:		ADC $54
c4ac:		STA $54
c4ae:		PLA
c4af:		ADC $55
c4b1:		ASL $52
c4b3:		ROL $53
c4b5:		ROL $54
c4b7:		ROL A
c4b8:		BMI c46a + 1
c4ba:		STA $55
c4bc:		PLA
c4bd:		ADC $52
c4bf:		STA $52
c4c1:		BCC c4cf
c4c3:		INC $53
c4c5:		BNE c4cf
c4c7:		INC $54
c4c9:		BNE c4cf
c4cb:		INC $55
c4cd:		BMI c46a + 1
c4cf:		LDX #$ff
c4d1:		BNE c477
c4d3:		TXA
c4d4:		BEQ c463
c4d6:		SEC
c4d7:		STY $3
c4d9:		LDY #$52
c4db:		JMP c99f


c4de:		JSR c279		; Test for '=', BRK if failure
c4e1:		JSR c78b		; Evaluate numerical expression


; Interpreter Post-Test subroutine
;
; Checks that (5),Y where y=?3 points to a statement delimiter ';' or <CR>
; or spaces leading thereto.
; If successful, consolidates the (5),Y pointer.
; If unsuccessful, BRK if failure.

c4e4:		LDY $3
c4e6:		DEY
c4e7:		INY
c4e8:		LDA ($5),Y
c4ea:		CMP #$20
c4ec:		BEQ c4e7
c4ee:		CMP #$3b
c4f0:		BEQ c4f6
c4f2:		CMP #$d
c4f4:		BNE c55b + 1


; Consolidate (5),Y Pointer subroutine
;
; Resets the text pointer by setting (5)=(5)+Y and Y=1 where Y=?3.

c4f6:		CLC
c4f7:		TYA
c4f8:		ADC $5
c4fa:		STA $5
c4fc:		BCC c500
c4fe:		INC $6
c500:		LDY #$1
c502:		STY $3


; Check for <ESC> key subroutine
;
; If <ESC> pressed then RTS, otherwise jumps to the Direct Mode.

c504:		LDA $b001
c507:		AND #$20
c509:		BEQ c547
c50b:		RTS


; Get Current Text Line Number subroutine
;
; Copies the new line number to 1,2 and updates the label address if the
; line is labelled.
; Sets up the (5),Y text pointer to the start of the statement.

c50c:		JSR c4e4
c50f:		DEY
c510:		LDA ($5),Y
c512:		CMP #$3b
c514:		BEQ c50b
c516:		LDA $6
c518:		CMP #$1
c51a:		BEQ c595 + 1
c51c:		INY
c51d:		LDA ($5),Y
c51f:		BMI c55b + 1
c521:		STA $2
c523:		INY
c524:		LDA ($5),Y
c526:		STA $1
c528:		INY
c529:		LDA ($5),Y
c52b:		DEY
c52c:		CMP #$61
c52e:		BCC c4f7
c530:		SBC #$61
c532:		CMP #$1b
c534:		BCS c4f6
c536:		INY
c537:		ASL A
c538:		TAX
c539:		JSR c4f6
c53c:		LDA $5
c53e:		STA VARSTORE + 1,X
c541:		LDA $6
c543:		STA VARSTORE + 2,X
c546:		RTS

c547:		JMP c2cf


; Statement Executer
;
; Executes a statement pointed to by (5),Y.
; Jumps indirectly to the FP ROM via ($D002) if the command cannot be
; interpreted.

c54a:		DEY
c54b:		JSR c4f6
c54e:		BNE c55b
c550:		JSR c424		; Handle unrecognised statement
c553:		BCC do_input_num
c555:		JMP ($d002)
do_input_num:	JSR c4e4


; Return Routine
;
; All routines generally return to BASIC here.
; Goes on to interpret the next statement.

c55b:		LDY #$0
c55d:		LDA ($5),Y
c55f:		CMP #$3b
c561:		BNE c57d
c563:		JMP do_then


; Execute the command 'IF'
;
; Puts a zero on the Workspace Stack at $16,X where X=?4 if false.

c566:		JSR c70c
c569:		DEX
c56a:		STX $4
c56c:		LDA $16,X
c56e:		BEQ c575
c570:		LDX #cmd_tbl_if - cmd_tbl
c572:		JMP c233


; Execute the command 'REM'
;
; Increments (5),Y until a <CR> is found.

c575:		LDA #$d
c577:		DEY
c578:		INY
c579:		CMP ($5),Y
c57b:		BNE c578
c57d:		LDA $6
c57f:		CMP #$1
c581:		BEQ c547
c583:		JSR c51c
c586:		JMP do_then


; Print Decimal subroutine
;
; Prints the lowest level of the Workspace Stack $16,$25,$34,$43 as a
; signed decimal number in field size set by the LSB of the integer
; variable '@' $321.
; Destroys A,X,Y registers.

c589:		LDA $43
c58b:		STA $27
c58d:		BPL c593
c58f:		INX
c590:		JSR c8c4
c593:		LDX #$9
c595:		LDA #$0
c597:		STA $45,X
c599:		SEC
c59a:		LDA $16
c59c:		SBC c608,X
c59f:		PHA
c5a0:		LDA $25
c5a2:		SBC c610,X
c5a5:		PHA
c5a6:		LDA $34
c5a8:		SBC c610 + $a,X
c5ab:		TAY
c5ac:		LDA $43
c5ae:		SBC c620 + 4,X
c5b1:		BCC c5c1
c5b3:		STA $43
c5b5:		STY $34
c5b7:		PLA
c5b8:		STA $25
c5ba:		PLA
c5bb:		STA $16
c5bd:		INC $45,X
c5bf:		BNE c599
c5c1:		PLA
c5c2:		PLA
c5c3:		DEX
c5c4:		BPL c595
c5c6:		LDX #$a
c5c8:		DEX
c5c9:		BEQ c5cf
c5cb:		LDA $45,X
c5cd:		BEQ c5c8
c5cf:		STX $52
c5d1:		BIT $27
c5d3:		BPL c5d7
c5d5:		INC $52
c5d7:		SEC
c5d8:		LDA WORKSP + $121
c5db:		BEQ c5df
c5dd:		SBC #$1
c5df:		SBC $52
c5e1:		BEQ c5ee
c5e3:		BCC c5ee
c5e5:		TAY
c5e6:		LDA #$20
c5e8:		JSR ca4c
c5eb:		DEY
c5ec:		BNE c5e6
c5ee:		BIT $27
c5f0:		BPL c5f7
c5f2:		LDA #$2d
c5f4:		JSR ca4c
c5f7:		LDA $45,X
c5f9:		CMP #$a
c5fb:		BCC c5ff
c5fd:		ADC #$6
c5ff:		ADC #$30
c601:		JSR ca4c
c604:		DEX
c605:		BPL c5f7
c607:		RTS


; Decimal Print Data Table

c608:		.text $01, $0a, $64, $e8, $10, $a0, $40, $80
c610:		.text $00, $00, $00, $03, $27, $86, $42, $96, $e1, $ca, $00, $00, $00, $00, $00, $01
c620:		.text $0f, $98, $f5, $9a, $00, $00, $00, $00, $00, $00, $00, $00, $05, $3b


; Line Number Search subroutine
;
; Searches text looking for a line number match.
; Line number searched for is assumed to be on the 16,X Workspace Stack
; where X=?4-1.
; Returns with (58),Y pointing to the character following the line number
; and Carry clear.
; Failure indicated by Carry set.

c62e:		DEC $4
c630:		LDX $4
c632:		LDY #$0
c634:		STY $58
c636:		LDA $12
c638:		STA $59
c63a:		DEY
c63b:		LDA #$d
c63d:		INY
c63e:		CMP ($58),Y
c640:		BNE c63d
c642:		JSR cea1
c645:		LDA ($58),Y
c647:		INY
c648:		CMP $25,X
c64a:		BCC c63b
c64c:		BNE c660
c64e:		LDA ($58),Y
c650:		CMP $16,X
c652:		BCC c63b
c654:		BNE c660
c656:		STA $1
c658:		LDA $25,X
c65a:		STA $2
c65c:		JSR cea1
c65f:		CLC
c660:		RTS


; Set up Miscellaneous Workspace for Multiply or Divide subroutine

c661:		JSR c8bc
c664:		LDA $42,X
c666:		EOR $41,X
c668:		STA $52
c66a:		JSR c905
c66d:		LDY #$53
c66f:		JSR c3cd
c672:		LDA $42,X
c674:		STA $43,X
c676:		JSR c907
c679:		LDY #$57
c67b:		JSR c3cd
c67e:		LDY #$0
c680:		STY $5b
c682:		STY $5c
c684:		STY $5d
c686:		STY $5e
c688:		RTS


; Division subroutine
;
; Do division in miscellaneous workspace.

c689:		JSR c661
c68c:		LDA $54
c68e:		JSR c705
c691:		BEQ c67e + 1
c693:		LDY #$20
c695:		DEY
c696:		BEQ c6d9
c698:		ASL $57
c69a:		ROL $58
c69c:		ROL $59
c69e:		ROL $5a
c6a0:		BPL c695
c6a2:		ROL $57
c6a4:		ROL $58
c6a6:		ROL $59
c6a8:		ROL $5a
c6aa:		ROL $5b
c6ac:		ROL $5c
c6ae:		ROL $5d
c6b0:		ROL $5e
c6b2:		SEC
c6b3:		LDA $5b
c6b5:		SBC $53
c6b7:		PHA
c6b8:		LDA $5c
c6ba:		SBC $54
c6bc:		PHA
c6bd:		LDA $5d
c6bf:		SBC $55
c6c1:		TAX
c6c2:		LDA $5e
c6c4:		SBC $56
c6c6:		BCC c6d4
c6c8:		STA $5e
c6ca:		STX $5d
c6cc:		PLA
c6cd:		STA $5c
c6cf:		PLA
c6d0:		STA $5b
c6d2:		BCS c6d6
c6d4:		PLA
c6d5:		PLA
c6d6:		DEY
c6d7:		BNE c6a2
c6d9:		RTS


; Relational Test subroutine

c6da:		JSR c78b
c6dd:		DEX
c6de:		STX $4
c6e0:		LDA $42,X
c6e2:		EOR #$80
c6e4:		STA $52
c6e6:		LDA $43,X
c6e8:		EOR #$80
c6ea:		STA $54
c6ec:		LDY #$0
c6ee:		SEC
c6ef:		LDA $15,X
c6f1:		SBC $16,X
c6f3:		STA $53
c6f5:		LDA $24,X
c6f7:		SBC $25,X
c6f9:		STA $55
c6fb:		LDA $33,X
c6fd:		SBC $34,X
c6ff:		STA $56
c701:		LDA $52
c703:		SBC $54
c705:		ORA $53
c707:		ORA $55
c709:		ORA $56
c70b:		RTS


; Truth Test subroutine
;
; Evaluates an arbitrarily complex expression pointed to by (5),Y where
; Y=?3 and places a zero on the Workspace Stack at 16,X where X=?4.
; Used by IF and UNTIL commands.

c70c:		JSR c72c
c70f:		LDX #cmd_43 - cmd_tbl
c711:		JMP c233


; Logical AND Truth Test

c714:		JSR c72c
c717:		LDA $14,X
c719:		AND $15,X
c71b:		STA $14,X
c71d:		DEC $4
c71f:		JMP c70f


; Logical OR Truth Test

c722:		JSR c72c
c725:		LDA $14,X
c727:		ORA $15,X
c729:		JMP c71b

c72c:		LDX #cmd_46 - cmd_tbl
c72e:		JMP c233


; '$' String Comparison Test

c731:		JSR c78b
c734:		JSR ceae
c737:		LDA $15,X
c739:		STA $54
c73b:		LDA $24,X
c73d:		STA $55
c73f:		LDY #$ff
c741:		INY
c742:		LDA ($54),Y
c744:		CMP ($52),Y
c746:		BNE c74f
c748:		EOR #$d
c74a:		BNE c741
c74c:		TAY
c74d:		BEQ c760
c74f:		LDY #$0
c751:		BEQ c761


c753:		JSR c78b
c756:		LDX #cmd_tbl_op - cmd_tbl
c758:		JMP c233


; Test <expression> = <expression>

do_eq:		JSR c6da
c75e:		BNE c761
c760:		INY
c761:		STY $15,X
c763:		RTS


; Test <expression> <= <expression>

do_le:		JSR c6da
c767:		BEQ c760
c769:		BCC c760
c76b:		BCS c761


; Test <expression> <> <expression>

do_ne:		JSR c6da
c770:		BNE c760
c772:		BEQ c761


; Test <expression> < <expression>

do_lt:		JSR c6da
c777:		BCC c760
c779:		BCS c761


; Test <expression> >= <expression>

do_ge:		JSR c6da
c77e:		BCS c760
c780:		BCC c761


; Test <expression> > <expression>

do_gt:		JSR c6da
c785:		BEQ c761
c787:		BCS c760
c789:		BCC c761


; <expression>

c78b:		JSR c80b
c78e:		JMP c795

c791:		STA $41,X
c793:		DEC $4
c795:		LDX #$0
c797:		JMP c27b


; Add 2 Numbers on the Workspace Stack
;
; {14,X 23,X 32,X 41,X} = {14,X 23,X 32,X 41,X} + {15,X 24,X 33,X 42,X}

c79a:		JSR c80b
c79d:		CLC
c79e:		LDA $14,X
c7a0:		ADC $15,X
c7a2:		STA $14,X
c7a4:		LDA $23,X
c7a6:		ADC $24,X
c7a8:		STA $23,X
c7aa:		LDA $32,X
c7ac:		ADC $33,X
c7ae:		STA $32,X
c7b0:		LDA $41,X
c7b2:		ADC $42,X
c7b4:		JMP c791


; Subtract 2 Numbers on the Workspace Stack
;
; {14,X 23,X 32,X 41,X} = {14,X 23,X 32,X 41,X} - {15,X 24,X 33,X 42,X}

c7b7:		JSR c80b
c7ba:		LDA $14,X
c7bc:		SBC $15,X
c7be:		STA $14,X
c7c0:		LDA $23,X
c7c2:		SBC $24,X
c7c4:		STA $23,X
c7c6:		LDA $32,X
c7c8:		SBC $33,X
c7ca:		STA $32,X
c7cc:		LDA $41,X
c7ce:		SBC $42,X
c7d0:		JMP c791


; Logically OR 2 Numbers on the Workspace Stack
;
; {14,X 23,X 32,X 41,X} = {14,X 23,X 32,X 41,X} OR {15,X 24,X 33,X 42,X}

c7d3:		JSR c80b
c7d6:		LDA $14,X
c7d8:		ORA $15,X
c7da:		STA $14,X
c7dc:		LDA $23,X
c7de:		ORA $24,X
c7e0:		STA $23,X
c7e2:		LDA $32,X
c7e4:		ORA $33,X
c7e6:		STA $32,X
c7e8:		LDA $41,X
c7ea:		ORA $42,X
c7ec:		JMP c791


; Logically EOR 2 Numbers on the Workspace Stack
;
; {14,X 23,X 32,X 41,X} = {14,X 23,X 32,X 41,X} EOR {15,X 24,X 33,X 42,X}

c7ef:		JSR c80b
c7f2:		LDA $14,X
c7f4:		EOR $15,X
c7f6:		STA $14,X
c7f8:		LDA $23,X
c7fa:		EOR $24,X
c7fc:		STA $23,X
c7fe:		LDA $32,X
c800:		EOR $33,X
c802:		STA $32,X
c804:		LDA $41,X
c806:		EOR $42,X
c808:		JMP c791


; <term>

c80b:		JSR c8bc
c80e:		LDX #$5
c810:		JMP c27b


; <factor> * <factor>

c813:		JSR c661
c816:		LSR $5a
c818:		ROR $59
c81a:		ROR $58
c81c:		ROR $57
c81e:		BCC c839
c820:		CLC
c821:		TYA
c822:		ADC $53
c824:		TAY
c825:		LDA $5c
c827:		ADC $54
c829:		STA $5c
c82b:		LDA $5d
c82d:		ADC $55
c82f:		STA $5d
c831:		LDA $5e
c833:		ADC $56
c835:		AND #$7f
c837:		STA $5e
c839:		ASL $53
c83b:		ROL $54
c83d:		ROL $55
c83f:		ROL $56
c841:		LDA $57
c843:		ORA $58
c845:		ORA $59
c847:		ORA $5a
c849:		BNE c816
c84b:		STY $5b
c84d:		LDA $52
c84f:		PHP
c850:		LDY #$5b
c852:		JSR c99f
c855:		PLP
c856:		BPL c85b
c858:		JSR c8c4
c85b:		JMP c80e


; <factor> / <factor>

c85e:		JSR c689
c861:		ROL $57
c863:		ROL $58
c865:		ROL $59
c867:		ROL $5a
c869:		BIT $52
c86b:		PHP
c86c:		LDY #$57
c86e:		BNE c852


; <factor> % <factor>

c870:		JSR c689
c873:		LDX $4
c875:		LDA $44,X
c877:		PHP
c878:		JMP c850


; <factor> & <factor>

c87b:		JSR c8bc
c87e:		DEX
c87f:		STX $4
c881:		LDA $15,X
c883:		AND $16,X
c885:		STA $15,X
c887:		LDA $24,X
c889:		AND $25,X
c88b:		STA $24,X
c88d:		LDA $33,X
c88f:		AND $34,X
c891:		STA $33,X
c893:		LDA $42,X
c895:		AND $43,X
c897:		STA $42,X
c899:		JMP c80e


; <factor> ? <factor>

c89c:		JSR c8a2
c89f:		JMP c80e
c8a2:		JSR c8bc
c8a5:		CLC
c8a6:		LDA $15,X
c8a8:		ADC $14,X
c8aa:		TAY
c8ab:		LDA $24,X
c8ad:		ADC $23,X
c8af:		DEX
c8b0:		JMP c953


; <factor> ! <factor>

c8b3:		JSR c8a2
c8b6:		JSR c962
c8b9:		JMP c80e


; Function Interpreter subroutine
;
; Evaluates an arbitrarily complex function pointed to by (5),Y where Y=?3
; and stores the result on the Workspace Stack pointed to by ?4.
; The (5),Y pointer is consolidated before return, so that (5),0 points to
; the last character in the string interpreted.
; The Workspace Stack pointer ?4 is incremented.

c8bc:		LDX #cmd_tbl_fnint - cmd_tbl
c8be:		JMP c233


; Negate Current Slot of Workspace Stack
;
; {15,X 24,X 33,X 42,X} = 0 - {15,X 24,X 33,X 42,X}

do_fnn:		JSR do_fnp


; Negate Current Slot of Workspace Stack subroutine
;
; {15,X 24,X 33,X 42,X} = 0 - {15,X 24,X 33,X 42,X}
; Destroys accumulator.

c8c4:		SEC
c8c5:		LDA #$0
c8c7:		TAY
c8c8:		SBC $15,X
c8ca:		STA $15,X
c8cc:		TYA
c8cd:		SBC $24,X
c8cf:		STA $24,X
c8d1:		TYA
c8d2:		SBC $33,X
c8d4:		STA $33,X
c8d6:		TYA
c8d7:		SBC $42,X
c8d9:		STA $42,X
c8db:		RTS


; Variable Assignment to Workspace

do_fnp:		JSR c434
c8df:		BCC c8f8
c8e1:		LDY $15,X


; Variable Assignment to Workspace Stack subroutine
;
; Copies the simple variable pointed to by Y (where 0=@, 1=A, etc to 26=Z)
; to the current slot of the Workspace Stack pointed to by ?4.
; Destroys accumulator.

c8e3:		LDA WORKSP + $121,Y
c8e6:		STA $15,X
c8e8:		LDA WORKSP + $157,Y
c8eb:		STA $33,X
c8ed:		LDA WORKSP + $13c,Y
c8f0:		STA $24,X
c8f2:		LDA WORKSP + $172,Y
c8f5:		STA $42,X
c8f7:		RTS


; Do Numerical Assignments

c8f8:		JSR c46a
c8fb:		BCS c8f7
c8fd:		LDX #cmd_tbl_numass - cmd_tbl
c8ff:		JMP c233


; Execute the Function 'ABS'
;
; Performs ABS of function pointed to by (5),Y and places the result on
; the Workspace Stack.

do_abs:		JSR c8bc
c905:		LDA $42,X
c907:		BMI c8c4
c909:		RTS


; Deal with '#'

do_hash:	LDX #$0
c90c:		STX $52
c90e:		STX $53
c910:		STX $54
c912:		STX $55
c914:		DEY
c915:		INY
c916:		LDA ($5),Y
c918:		CMP #$30
c91a:		BCC c93e
c91c:		CMP #$3a
c91e:		BCC c92a
c920:		SBC #$37
c922:		CMP #$a
c924:		BCC c93e
c926:		CMP #$10
c928:		BCS c93e
c92a:		ASL A
c92b:		ASL A
c92c:		ASL A
c92d:		ASL A
c92e:		LDX #$3
c930:		ASL A
c931:		ROL $52
c933:		ROL $53
c935:		ROL $54
c937:		ROL $55
c939:		DEX
c93a:		BPL c930
c93c:		BMI c915
c93e:		TXA
c93f:		BPL c958 + 1
c941:		JMP c4d6


; Deal with '('

do_bktop:	JSR c70c
c947:		LDX #$c
c949:		JMP c27b


; Deal with '?'

do_query:	JSR c8bc
c94f:		LDY $15,X
c951:		LDA $24,X
c953:		STA $53
c955:		STY $52
c957:		DEX
c958:		LDY #$0
c95a:		LDA ($52),Y
c95c:		JMP c97c


; Deal with '!'

do_pling:	JSR do_query
c962:		LDY #$1
c964:		LDA ($52),Y
c966:		STA $24,X
c968:		INY
c969:		LDA ($52),Y
c96b:		STA $33,X
c96d:		INY
c96e:		LDA ($52),Y
c970:		STA $42,X
c972:		RTS


; Read TOP onto Workspace Stack subroutine
;
; Reads the TOP value at $D,$E onto the current workspace slot.
; The Workspace Stack pointer ?4 is incremented.

do_top:		LDY #$d
c975:		JSR c9a1
c978:		BEQ c981


; Read COUNT onto Workspace Stack subroutine
;
; Reads the COUNT value at ?7 onto the current workspace slot

do_count:	LDA $7
c97c:		JSR c9b3
c97f:		STA $24,X
c981:		STA $33,X
c983:		STA $42,X
c985:		RTS


; Execute the Function 'RND' subroutine
;
; Generates a new random number at $8,$9,$A,$B,$C and copies it to the
; current slot of the Workspace Stack pointed to by ?4.
; The Workspace Stack pointer ?4 is incremented.

do_rnd:		LDY #$20
c988:		LDA $a
c98a:		LSR A
c98b:		LSR A
c98c:		LSR A
c98d:		EOR $c
c98f:		ROR A
c990:		ROL $8
c992:		ROL $9
c994:		ROL $a
c996:		ROL $b
c998:		ROL $c
c99a:		DEY
c99b:		BNE c988
c99d:		LDY #$8
c99f:		LDX $4
c9a1:		LDA $1,Y
c9a4:		STA $25,X
c9a6:		LDA $2,Y
c9a9:		STA $34,X
c9ab:		LDA $3,Y
c9ae:		STA $43,X
c9b0:		LDA $0,Y
c9b3:		STA $16,X
c9b5:		INX
c9b6:		STX $4
c9b8:		LDY $3
c9ba:		LDA #$0
c9bc:		RTS


; Execute the Function 'LEN'

c9bd:		JSR c8bc
c9c0:		JSR c3cb
c9c3:		LDY #$0
c9c5:		LDA #$d
c9c7:		CMP ($52),Y
c9c9:		BEQ c9ce
c9cb:		INY
c9cc:		BNE c9c7
c9ce:		TYA
c9cf:		JMP c97c


; Deal with the 'CH' operator

do_ch:		JSR ceb1
c9d5:		JMP c958


; BRK Handler
;
; Points the BASIC interpreter at the vector ($10,$11) which is normally
; set to point to C9E7.
; Exits to the Diect Mode.

c9d8:		PLA
c9d9:		PLA
c9da:		STA $0
c9dc:		LDA $10
c9de:		STA $5
c9e0:		LDA $11
c9e2:		STA $6
c9e4:		JMP c2f2


c9e7:		.text "@=1;P.$6$7'""ERROR ""?0;@=8;IF?1|?2P."" LINE""!1& #FFFF", $0d, $00, $00, "P.';E.", $0d


; Handle Unrecognised Command
;
; Jumps indirectly to ($D002) if the FP ROM exists, otherwise executes BRK.

ca24:		JSR c424
ca27:		BCC c9e7 + 52
ca29:		JMP ($d004)


; Assign Integer Variable
;
; Copies the last value on the Workspace Stack to the integer variable
; pointed to by Y (where 0=@, 1=A, etc to 26=Z).
; Workspace Stack pointer is decremented TWICE.

ca2c:		JSR c78b
ca2f:		LDX $4
ca31:		DEX
ca32:		DEX
ca33:		STX $4
ca35:		LDY $16,X


; Assign Integer Variable subroutine
;
; Copies the value on the Workspace Stack pointed to by X to the integer
; variable pointed to by Y (where 0=@, 1=A, etc to 26=Z).
; Destroys accumulator.

ca37:		LDA $17,X
ca39:		STA WORKSP + $121,Y
ca3c:		LDA $26,X
ca3e:		STA WORKSP + $13c,Y
ca41:		LDA $35,X
ca43:		STA WORKSP + $157,Y
ca46:		LDA $44,X
ca48:		STA WORKSP + $172,Y
ca4b:		RTS


; Increment 'COUNT' and Print Character subroutine
;
; Increments COUNT at ?7 and the prints the contents of the accumulator.

ca4c:		INC $7
ca4e:		JMP (WRCVEC)


; Execute the Command 'LIST'
;
; X register must be zero on entry.
; Exits to the Direct Mode.

ca51:		LDA #$0
ca53:		JSR c97c
ca56:		LDA #$ff
ca58:		JSR c97c
ca5b:		STA $4
ca5d:		LDY #$7f
ca5f:		STY $26
ca61:		JSR c465
ca64:		BCC cab8
ca66:		JSR c231
ca69:		BCS cac3
ca6b:		JSR c465
ca6e:		LDX #$1
ca70:		STX $4
ca72:		JSR c4e4
ca75:		JSR c62e
ca78:		BCC caaa
ca7a:		DEY
ca7b:		BCS ca9e
ca7d:		LDA #$5
ca7f:		STA WORKSP + $121
ca82:		JSR c589
ca85:		LDA #$8
ca87:		STA WORKSP + $121
ca8a:		LDY $3
ca8c:		LDA ($58),Y
ca8e:		CMP #$d
ca90:		BEQ ca98
ca92:		JSR ca4c
ca95:		INY
ca96:		BNE ca8c
ca98:		JSR cd54
ca9b:		JSR cea1
ca9e:		LDA ($58),Y
caa0:		STA $25
caa2:		INY
caa3:		LDA ($58),Y
caa5:		STA $16
caa7:		INY
caa8:		STY $3
caaa:		LDA $16
caac:		CLC
caad:		SBC $17
caaf:		LDA $25
cab1:		SBC $26
cab3:		BCC ca7d
cab5:		JMP c2cf
cab8:		JSR c231
cabb:		INC $4
cabd:		JSR c465
cac0:		JMP ca6e
cac3:		LDA $16
cac5:		LDY $25
cac7:		STA $17
cac9:		STY $26
cacb:		BCS ca6e


; Execute the Command 'NEXT'

cacd:		JSR c434
cad0:		LDY $15
cad2:		BEQ cae4
cad4:		BCC cae5
cad6:		DEC $4
cad8:		LDA $15,X
cada:		CMP WORKSP + $03f,Y
cadd:		BEQ cae5
cadf:		DEY
cae0:		STY $15
cae2:		BNE cada
cae4:		BRK
cae5:		LDX WORKSP + $03f,Y
cae8:		CLC
cae9:		LDA WORKSP + $121,X
caec:		ADC WORKSP + $04a,Y
caef:		STA WORKSP + $121,X
caf2:		STA $52
caf4:		LDA WORKSP + $13c,X
caf7:		ADC WORKSP + $055,Y
cafa:		STA WORKSP + $13c,X
cafd:		STA $53
caff:		LDA WORKSP + $157,X
cb02:		ADC WORKSP + $060,Y
cb05:		STA WORKSP + $157,X
cb08:		STA $54
cb0a:		LDA WORKSP + $172,X
cb0d:		ADC WORKSP + $06b,Y
cb10:		STA WORKSP + $172,X
cb13:		TAX
cb14:		LDA $52
cb16:		SEC
cb17:		SBC WORKSP + $076,Y
cb1a:		STA $52
cb1c:		LDA $53
cb1e:		SBC WORKSP + $081,Y
cb21:		STA $53
cb23:		LDA $54
cb25:		SBC WORKSP + $08c,Y
cb28:		STA $54
cb2a:		TXA
cb2b:		SBC WORKSP + $097,Y
cb2e:		ORA $52
cb30:		ORA $53
cb32:		ORA $54
cb34:		BEQ cb45
cb36:		TXA
cb37:		EOR WORKSP + $06b,Y
cb3a:		EOR WORKSP + $097,Y
cb3d:		BPL cb43
cb3f:		BCS cb45
cb41:		BCC cb52
cb43:		BCS cb52
cb45:		LDA WORKSP + $0a2,Y
cb48:		STA $5
cb4a:		LDA WORKSP + $0ad,Y
cb4d:		STA $6
cb4f:		JMP cbff

cb52:		DEC $15
cb54:		JMP do_input_num


; Execute the Command 'FOR'

cb57:		JSR c434
cb5a:		BCC cb6c + 1
cb5c:		JSR c279
cb5f:		JSR ca2c
cb62:		TYA
cb63:		LDY $15
cb65:		CPY #$b
cb67:		BCS cb6c + 1
cb69:		STA WORKSP + $040,Y
cb6c:		LDA #$0
cb6e:		STA WORKSP + $06c,Y
cb71:		STA WORKSP + $061,Y
cb74:		STA WORKSP + $056,Y
cb77:		LDA #$1
cb79:		STA WORKSP + $04b,Y
cb7c:		LDX #cmd_tbl_for - cmd_tbl
cb7e:		JMP c233


; Execute the Command 'TO'

do_to:		JSR c78b
cb84:		LDY $15
cb86:		DEX
cb87:		STX $4
cb89:		LDA $16,X
cb8b:		STA WORKSP + $077,Y
cb8e:		LDA $25,X
cb90:		STA WORKSP + $082,Y
cb93:		LDA $34,X
cb95:		STA WORKSP + $08d,Y
cb98:		LDA $43,X
cb9a:		STA WORKSP + $098,Y
cb9d:		LDX #cmd_tbl_forto - cmd_tbl
cb9f:		JMP c233


; Execute the Command 'STEP'

do_step:	JSR c78b
cba5:		LDY $15
cba7:		DEX
cba8:		STX $4
cbaa:		LDA $16,X
cbac:		STA WORKSP + $04b,Y
cbaf:		LDA $25,X
cbb1:		STA WORKSP + $056,Y
cbb4:		LDA $34,X

cbb6:		STA WORKSP + $061,Y
cbb9:		LDA $43,X
cbbb:		STA WORKSP + $06c,Y

			; CONFLICT: some ROM binaries say:
			; CBB6  99 62 02  STA $262,Y	; 62 not 61
			; CBB9  B5 43     LDA $43,X
			; CBBB  99 6d 02  STA $26D,Y	; 6D not 6C


cbbe:		JSR c50c
cbc1:		LDY $15
cbc3:		LDA $5
cbc5:		STA WORKSP + $0a3,Y
cbc8:		LDA $6
cbca:		STA WORKSP + $0ae,Y
cbcd:		INC $15
cbcf:		JMP do_then


; Execute the Command 'GOSUB'

cbd2:		JSR cc1f
cbd5:		JSR c50c
cbd8:		LDY $14
cbda:		CPY #$e
cbdc:		BCS cbff + 1
cbde:		LDA $5
cbe0:		STA WORKSP + $0cf,Y
cbe3:		LDA $6
cbe5:		STA WORKSP + $0dd,Y
cbe8:		INC $14
cbea:		BCC cc0b


; Execute the Command 'RETURN'

cbec:		JSR c4e4
cbef:		LDY $14
cbf1:		BEQ cc1d
cbf3:		DEC $14
cbf5:		LDA WORKSP + $0ce,Y
cbf8:		STA $5
cbfa:		LDA WORKSP + $0dc,Y
cbfd:		STA $6
cbff:		JSR c500
cc02:		JMP do_then


; Execute the Command 'GOTO'

cc05:		JSR cc1f
cc08:		JSR c4e4
cc0b:		LDA $57
cc0d:		BNE cc14
cc0f:		JSR c62e
cc12:		BCS cc7c + 1
cc14:		LDY $58
cc16:		LDA $59
cc18:		STY $5
cc1a:		JMP cbfd

cc1d:		BRK


; Line Number/Label Text Search subroutine
;
; Used by 'GOTO' and 'GOSUB' routines.
; Line number copied to $1,$2 if the search is successful.
; If the label address is known, it is copied to $58,$59.
; If the label address is not known, it is searched for and copied to the
; label store as well as to $58,$59.

cc1e:		INY
cc1f:		LDA ($5),Y
cc21:		CMP #$20
cc23:		BEQ cc1e
cc25:		CMP #$61
cc27:		BCC cc79
cc29:		STA $57
cc2b:		SBC #$61
cc2d:		CMP #$1b
cc2f:		BCS cc79
cc31:		ASL A
cc32:		TAX
cc33:		LDA VARSTORE + 1,X
cc36:		STA $58
cc38:		JSR c4f6
cc3b:		LDA VARSTORE + 2,X
cc3e:		STA $59
cc40:		ORA $58
cc42:		BNE cc78
cc44:		TAY
cc45:		LDA $12
cc47:		STA $59
cc49:		DEY
cc4a:		LDA #$d
cc4c:		INY
cc4d:		CMP ($58),Y
cc4f:		BNE cc4c
cc51:		INY
cc52:		LDA ($58),Y
cc54:		BMI cc9a + 1
cc56:		STA $2
cc58:		INY
cc59:		LDA ($58),Y
cc5b:		STA $1
cc5d:		INY
cc5e:		LDA ($58),Y
cc60:		DEY
cc61:		CMP $57
cc63:		BEQ cc6b
cc65:		JSR cea1
cc68:		JMP cc4a

cc6b:		JSR cea2
cc6e:		LDA $58
cc70:		STA VARSTORE + 1,X
cc73:		LDA $59
cc75:		STA VARSTORE + 2,X
cc78:		RTS


cc79:		JSR c8bc
cc7c:		LDA #$0
cc7e:		STA $57
cc80:		RTS


; Execute the Command 'INPUT'

do_input:	JSR c372
cc84:		JSR c434
cc87:		BCS cc8e
cc89:		LDX #cmd_tbl_input - cmd_tbl
cc8b:		JMP c233


; Numerical Variable Input

cc8e:		JSR cd09
cc91:		LDA $5
cc93:		PHA
cc94:		LDA $6
cc96:		PHA
cc97:		LDA $3
cc99:		PHA
cc9a:		LDY #$0
cc9c:		STY $3
cc9e:		INY
cc9f:		STY $6
cca1:		LDY #$40
cca3:		STY $5
cca5:		JSR ca2c
cca8:		PLA
cca9:		STA $3
ccab:		PLA
ccac:		STA $6
ccae:		PLA
ccaf:		STA $5
ccb1:		LDX #cmd_2c - cmd_tbl
ccb3:		JMP c233


; String Variable Input

do_strvar:	JSR c78b
ccb9:		LDY #$54
ccbb:		JSR c3cd
ccbe:		JSR cd09
ccc1:		LDX #$40
ccc3:		LDY #$0
ccc5:		LDA $100,X
ccc8:		STA ($54),Y
ccca:		CMP #$d
cccc:		BEQ do_input
ccce:		INX
cccf:		INY
ccd0:		BNE ccc5


; Execute the Command 'UNTIL'

ccd2:		JSR c70c
ccd5:		LDY $13
ccd7:		BEQ ccc3 + 1
ccd9:		DEX
ccda:		STX $4
ccdc:		LDA $16,X
ccde:		BEQ cce5
cce0:		DEC $13
cce2:		JMP do_input_num

cce5:		LDA WORKSP + $0b8,Y
cce8:		STA $5
ccea:		LDA WORKSP + $0c3,Y
cced:		JMP cbfd


; Execute the Command 'DO'

ccf0:		LDX $13
ccf2:		CPX #$b
ccf4:		BCS cd0f + 1
ccf6:		DEY
ccf7:		JSR c4f6
ccfa:		LDA $5
ccfc:		STA WORKSP + $0b9,X
ccff:		LDA $6
cd01:		STA WORKSP + $0c4,X
cd04:		INC $13
cd06:		JMP do_then


; Input to String Input Buffer subroutine
;
; Prints a '?' prompt and stores subsequent keypresses in the $140 string
; input buffer.
; Returns when <CR> pressed with Y register pointing to the last character
; entered.
; COUNT is set to zero on return.

cd09:		LDA #$3f
cd0b:		LDY #$40
cd0d:		BNE cd11


; Input a Line to Direct Mode Input Buffer subroutine
;
; Prints the contents of the accumulator and stores subsequent keypresses
; in the $100 Direct Mode input buffer.
; Returns when <CR> pressed with Y register pointing to the last character
; entered.
; COUNT is set to zero on return.

cd0f:		LDY #$0
cd11:		JSR ca4c
cd14:		STY $52
cd16:		LDY $52
cd18:		JSR OSECHO
cd1b:		CMP #$7f
cd1d:		BNE cd26
cd1f:		DEY
cd20:		CPY $52
cd22:		BPL cd18
cd24:		BMI cd16
cd26:		CMP #$18
cd28:		BNE cd30
cd2a:		JSR cd54
cd2d:		JMP cd16

cd30:		CMP #$1b
cd32:		BNE cd37
cd34:		JMP c2cf

cd37:		STA $100,Y
cd3a:		CMP #$d
cd3c:		BEQ cd57
cd3e:		INY
cd3f:		TYA
cd40:		SEC
cd41:		SBC $52
cd43:		CMP #$40
cd45:		BCC cd18
cd47:		JSR OSRDCH
cd4a:		CMP #$7f
cd4c:		BNE cd47
cd4e:		JSR OSWRCH
cd51:		JMP cd1f


; Print a <CR><LF> subroutine
;
; Sends a <CR><LF> to WRCHAR, and resets COUNT at ?7 to zero.
; Destroys accumulator.

cd54:		JSR OSCRLF
cd57:		LDA #$0
cd59:		STA $7
cd5b:		RTS


; Assign '$' String Variable

cd5c:		JSR c78b
cd5f:		JSR ceae
cd62:		LDY #$54
cd64:		JSR c3cd
cd67:		LDY #$ff
cd69:		INY
cd6a:		LDA ($52),Y
cd6c:		STA ($54),Y
cd6e:		CMP #$d
cd70:		BNE cd69
cd72:		JMP do_input_num


; Assign !<variable>

cd75:		JSR cd81
cd78:		JMP c3f1


; Assign ?<variable>

cd7b:		JSR cd81
cd7e:		JMP c409


; Assignment subroutine

cd81:		JSR c8e1
cd84:		JSR c8bc
cd87:		DEX
cd88:		CLC
cd89:		LDA $16,X
cd8b:		ADC $15,X
cd8d:		STA $15,X
cd8f:		LDA $25,X
cd91:		ADC $24,X
cd93:		STA $24,X
cd95:		STX $4
cd97:		RTS


; Execute the Command 'END'
;
; Finds the end of the current text space, starting at page ?$12, and
; sets the TOP vector $D, $E.
; Exits to Direct Mode.

cd98:		JSR c4e4
cd9b:		LDA $12
cd9d:		STA $e
cd9f:		LDY #$0
cda1:		STY $d
cda3:		DEY
cda4:		INY
cda5:		LDA ($d),Y
cda7:		CMP #$d
cda9:		BNE cda4
cdab:		JSR cdbc
cdae:		LDA ($d),Y
cdb0:		BMI cdb5
cdb2:		INY
cdb3:		BNE cda4
cdb5:		INY
cdb6:		JSR cdbc
cdb9:		JMP c2cf


; END subroutine
;
; Sets TOP=TOP+Y and Y=1.

cdbc:		CLC
cdbd:		TYA
cdbe:		ADC $d
cdc0:		STA $d
cdc2:		BCC cdc6
cdc4:		INC $e
cdc6:		LDY #$1
cdc8:		RTS


; Text Line Insertion and Removal
;
; On entry $16, $17 contain the line number to be entered.

cdc9:		STY $56
cdcb:		JSR c62e
cdce:		BCS ce18
cdd0:		LDA $58
cdd2:		STA $52
cdd4:		SBC #$1
cdd6:		STA $58
cdd8:		STA $d
cdda:		LDA $59
cddc:		STA $53
cdde:		SBC #$0
cde0:		STA $e
cde2:		STA $59
cde4:		LDA #$d
cde6:		INY
cde7:		CMP ($52),Y
cde9:		BNE cde6
cdeb:		CLC
cdec:		TYA
cded:		ADC $52
cdef:		STA $52
cdf1:		BCC cdf5
cdf3:		INC $53
cdf5:		LDY #$0
cdf7:		LDA ($52),Y
cdf9:		STA ($d),Y
cdfb:		CMP #$d
cdfd:		BEQ ce08
cdff:		INY
ce00:		BNE cdf7
ce02:		INC $53
ce04:		INC $e
ce06:		BNE cdf7
ce08:		INY
ce09:		BNE ce0f
ce0b:		INC $53
ce0d:		INC $e
ce0f:		LDA ($52),Y
ce11:		STA ($d),Y
ce13:		BPL cdff
ce15:		JSR cdbd
ce18:		LDY #$1
ce1a:		STY $57
ce1c:		DEY
ce1d:		LDA #$d
ce1f:		CMP ($56),Y
ce21:		BEQ ce80
ce23:		INY
ce24:		CMP ($56),Y
ce26:		BNE ce23
ce28:		INY
ce29:		INY
ce2a:		LDA $d
ce2c:		STA $54
ce2e:		LDA $e
ce30:		STA $55
ce32:		JSR cdbd
ce35:		STA $52
ce37:		LDA $e
ce39:		STA $53
ce3b:		DEY
ce3c:		LDA #$55
ce3e:		STA ($d),Y
ce40:		CMP ($d),Y
ce42:		BNE cdf5 + 1
ce44:		ASL A
ce45:		STA ($d),Y
ce47:		CMP ($d),Y
ce49:		BNE cdf5 + 1
ce4b:		LDA ($54),Y
ce4d:		STA ($52),Y
ce4f:		TYA
ce50:		BNE ce56
ce52:		DEC $55
ce54:		DEC $53
ce56:		DEY
ce57:		TYA
ce58:		ADC $54
ce5a:		LDX $55
ce5c:		BCC ce5f
ce5e:		INX
ce5f:		CMP $58
ce61:		TXA
ce62:		SBC $59
ce64:		BCS ce4b
ce66:		LDY #$1
ce68:		LDA $25
ce6a:		STA ($58),Y
ce6c:		INY
ce6d:		LDA $16
ce6f:		STA ($58),Y
ce71:		SEC
ce72:		JSR cea2
ce75:		LDY #$ff
ce77:		INY
ce78:		LDA ($56),Y
ce7a:		STA ($58),Y
ce7c:		CMP #$d
ce7e:		BNE ce77
ce80:		JMP c2cf


; Continuation of Execution of the Command 'RUN'
;
; Continuation from $F141.
; Sets the Text Pointer at ?5,?6 to the start of text, and then jumps to
; the interpreter.

ce83:		JSR c4e4
ce86:		LDY #$0
ce88:		STY $5
ce8a:		STY $3
ce8c:		LDA $12
ce8e:		STA $6
ce90:		JMP c55b


; !<factor> and ?<factor> subroutine

ce93:		JSR c4de
ce96:		DEX
ce97:		JSR c3cb
ce9a:		LDY #$0
ce9c:		LDA $17,X
ce9e:		STA ($52),Y
cea0:		RTS


; Update $58, $59 Pointer subroutine
;
; Sets ($58)=($58)+Y and Y=1, ?3=1.
; Checks the <ESC> key before return.
; Destroys accumulator.

cea1:		CLC
cea2:		TYA
cea3:		ADC $58
cea5:		STA $58
cea7:		BCC ceab
cea9:		INC $59
ceab:		JMP c500


; Set up String Ready for Assignment

ceae:		JSR c279


; Check for Valid String subroutine
;
; Checks for '$' or '"' at the location pointed to by (5),Y where y=?3.
; If successful, returns with (5),?3 pointimg to the character following,
; otherwise executes BRK.

ceb1:		LDX #cmd_tbl_str - cmd_tbl
ceb3:		JMP c233


; Set up $ String Ready for Asssignment

do_str:		JSR c78b
ceb9:		JSR c3cb
cebc:		LDY $3
cebe:		RTS


; Set up "string" Ready for Asssignment

do_quote:	JSR c4f6


; Copy Quoted String to String Input Buffer subroutine
;
; Copies a string in quotes pointed to by (5),Y to the string input buffer
; at $140.
; Quotation marks are removed.

cec2:		STY $53
cec4:		DEY
cec5:		LDX #$0
cec7:		LDA ($5),Y
cec9:		CMP #$d
cecb:		BEQ cec5 + 1
cecd:		STA $140,X
ced0:		INX
ced1:		INY
ced2:		CMP #$22
ced4:		BNE cec7
ced6:		LDA ($5),Y
ced8:		CMP #$22
ceda:		BEQ ceea
cedc:		LDA #$d
cede:		STA $13f,X
cee1:		STY $3
cee3:		LDA #$40
cee5:		STA $52
cee7:		LDX $4
cee9:		RTS

ceea:		INY
ceeb:		BCS cec7


; 'LOAD' File

ceed:		JSR cefa
cef0:		DEY
cef1:		STY $56
cef3:		SEC
cef4:		JSR OSLOAD
cef7:		JMP cd9b


; Load and Save Setup subroutine
;
; Reads the file title into the String Input buffer at $140, and sets
; the vector $54, $55 to the start of text.

cefa:		JSR ceb1
cefd:		JSR c4e4
cf00:		DEY
cf01:		STY $54
cf03:		LDA $12
cf05:		STA $55
cf07:		LDX #$52
cf09:		RTS


; Execute the Command 'SAVE'

cf0a:		JSR cefa
cf0d:		STY $58
cf0f:		STA $59
cf11:		LDA $d
cf13:		STA $5a
cf15:		LDA $e
cf17:		STA $5b
cf19:		LDA #$b2
cf1b:		STA $56
cf1d:		LDA #$c2
cf1f:		STA $57
cf21:		CLC
cf22:		JSR OSSAVE
cf25:		JMP c55b


; Execute the Commands 'EXT' and 'PTR'

do_ext:		SEC
do_ptr:		LDA #$0
cf2b:		ROL A
cf2c:		PHA
cf2d:		JSR cf3e
cf30:		LDX #$52
cf32:		PLA
cf33:		JSR OSRDAR
cf36:		LDY #$52
cf38:		JSR c99f
cf3b:		STA $42,X
cf3d:		RTS


; Get <factor> into Y Register subroutine

cf3e:		JSR c8bc
cf41:		LDY $15,X
cf43:		DEX
cf44:		STX $4
cf46:		RTS


cf47:		JSR c8bc
cf4a:		JSR c4de
cf4d:		JSR c3cb
cf50:		JSR cf41
cf53:		LDX #$52
cf55:		JSR OSSTAR
cf58:		JMP c55b


; Execute 'BGET' subroutine
;
; Reads 1 byte from OSBGET into the workspace stack and sets the other
; 3 bytes to zero.

do_bget:	JSR cf3e
cf5e:		STY $52
cf60:		JSR OSBGET
cf63:		JMP c97c


; Execute 'GET' subroutine
;
; Reads 4 bytes from OSBGET into the workspace stack.

do_get:		JSR do_bget
cf69:		LDY $52
cf6b:		JSR OSBGET
cf6e:		STA $24,X
cf70:		JSR OSBGET
cf73:		STA $33,X
cf75:		JSR OSBGET
cf78:		STA $42,X
cf7a:		RTS


cf7b:		JSR c8bc
cf7e:		JSR c231
cf81:		JSR c4e1
cf84:		JSR c3cb
cf87:		JSR cf41
cf8a:		LDA $52
cf8c:		JMP (BPTVEC)


; Execute the Command 'BPUT'

cf8f:		JSR cf7b
cf92:		JMP c55b


; Execute 'PUT', 'FIN' and 'FOUT' subroutines

cf95:		JSR cf7b
cf98:		LDX #$1
cf9a:		LDA $52,X
cf9c:		JSR OSBPUT
cf9f:		INX
cfa0:		CPX #$4
cfa2:		BCC cf9a
cfa4:		BCS cf92
do_fin:		SEC
do_fout:	PHP
cfa8:		JSR ceb1
cfab:		LDX #$52
cfad:		PLP
cfae:		JSR OSFIND
cfb1:		LDX $4
cfb3:		JMP c97c


cfb6:		JSR c8bc
cfb9:		JSR c4e4
cfbc:		JSR cf41
cfbf:		JSR OSSHUT
cfc2:		JMP c55b


; Execute the Command 'SPUT'

cfc5:		JSR c22c
cfc8:		JSR ceb1
cfcb:		JSR c4e4
cfce:		DEY
cfcf:		LDA ($52),Y
cfd1:		STY $55
cfd3:		LDY $f
cfd5:		PHA
cfd6:		JSR OSBPUT
cfd9:		PLA
cfda:		CMP #$d
cfdc:		BEQ cfc2
cfde:		LDY $55
cfe0:		INY
cfe1:		BNE cfcf


; Execute the Command 'SGET'

cfe3:		JSR c22c
cfe6:		JSR c4e1
cfe9:		JSR c3cb
cfec:		LDY #$0
cfee:		STY $55
cff0:		LDY $f
cff2:		JSR OSBGET
cff5:		LDY $55
cff7:		STA ($52),Y
cff9:		INY
cffa:		CMP #$d
cffc:		BNE cfee
cffe:		BEQ cfc2
